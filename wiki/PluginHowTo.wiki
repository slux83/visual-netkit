#summary How to make a plugin for VisualNetkit
#labels Featured,Phase-Implementation

=Making a simple plugin for a Virtual Machine element=
In this section we try to make a Plugin for a Virtual Machine. The plugin is very simple. It's just export the PS1 environment variable and some aliases.

Our plugin will have only two properties that can have two values ("true" or "false"):
 * `use PS1`
 * `use aliases`

The plugin name is *BashRC* because the plugin offer only one template builded in base of the properties values.

==The plugin.ini==
{{{
[global]
name=BashRC
type=vm
description="This plugin set PS1 env variable and/or some aliases in /root/.bashrc"
version=1.0
dependencies=""
author="Alessio Di Fazio"

[properties]
use PS1/p_default_value=true
use PS1/p_description="Set true if you want add a cool and coloured Bash promt inside the root .bashrc file, false otherwise"

use aliases/p_default_value=true
use aliases/p_description="Set true if you want add some useful aliases inside the root .bashrc file, false otherwise"
}}}

==The templates==
Inside our plugin we have three templates used to build the .bashrc final file!
===.bashrc - main===
{{{
#
# .bashrc file created by VisualNetkit BashRC plugin
#

umask 022
export TERM=xterm

# Bash completion
if [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
fi
}}}

===.bashrc - aliases part===
{{{
# Aliases
alias ls='ls --color'
alias grep='grep --color'
alias xorpsh='su xorp -p -c xorpsh'
alias ll='ls -lih --color'
alias la='ls -alh --color'
alias l='ls -ah --color'
alias ls='ls -h --color'
alias cd..='cd ..'
alias nano='nano -i -m -w -B -F -L'
}}}

===.bashrc - promt part===
{{{
# Bash promt
export PS1='\n\[\033[1;30m\][\[\033[0;33m\]\D{%d/%m/%Y %T}\[\033[1;30m\]]\n\[\033[31;04m\]\u\[\033[37;00m\]@\[\033[36;01m\]\h\[\033[37;00m\][\w]\n~> '
}}}

These two last templates is appended to the main .bashrc file if the properties are setted to "true".

==Implementing a plugin for VisualNetkit==
Sources:
 * [http://code.google.com/p/visual-netkit/source/browse/trunk/src/plugin_dev/bashrc/bashrc.pro bashrc/bashrc.pro]
 * [http://code.google.com/p/visual-netkit/source/browse/trunk/src/plugin_dev/bashrc/PluginBashRc.h bashrc/PluginBashRc.h]
 * [http://code.google.com/p/visual-netkit/source/browse/trunk/src/plugin_dev/bashrc/PluginBashRc.cpp bashrc/PluginBashRc.cpp]
 * [http://code.google.com/p/visual-netkit/source/browse/trunk/src/plugin_dev/bashrc/resources/resources.qrc bashrc/resources/resources.qrc]
 * [http://code.google.com/p/visual-netkit/source/browse/trunk/src/plugin_dev/bashrc/resources/plugin.ini bashrc/resources/plugin.ini]
 * [http://code.google.com/p/visual-netkit/source/browse/trunk/src/plugin_dev/bashrc/resources/bashrc bashrc/resources/bashrc]
 * [http://code.google.com/p/visual-netkit/source/browse/trunk/src/plugin_dev/bashrc/resources/ps1 bashrc/resources/ps1]
 * [http://code.google.com/p/visual-netkit/source/browse/trunk/src/plugin_dev/bashrc/resources/aliases bashrc/resources/aliases]

===bashrc.pro - Qt project file===
Project files contain all the information required by `qmake` to build your application, library, or plugin.

The most important variables are `TARGET`, `HEADERS` and `SOURCES`.
`TARGET` is the plugin (project) name. If you set `TARGET = foo` the plugin file will be named `libfoo.so`.

The `.pro` file for each plugin is quite standard; you have to change `HEADERS` and `SOURCES` but only adding plugin files such as PluginClass{.cpp .h} and other private classes. Do not touch the other files.

If you want more informations, please read the Qt-doc: http://doc.trolltech.com/4.4/qmake-project-files.html

===resources.qrc - Qt Resource system===
The Qt resource system is a platform-independent mechanism for storing binary files in the application's executable. This is useful if your application always needs a certain set of files (icons, translation files, etc.) and you don't want to run the risk of losing the files.

The resources associated with an application are specified in a `.qrc` file, an *XML-based* file format that lists files on the disk and optionally assigns them a resource name that the application must use to access the resource.

Our resource file:
{{{
<RCC>
    <qresource prefix="/" >
        <file alias="bash_main" >bashrc</file>
        <file alias="bash_aliases" >aliases</file>
        <file alias="bash_ps1" >ps1</file>
        <file alias="ini_bashrc" >plugin.ini</file>
    </qresource>
</RCC>
}}}

*NOTE:* The most important thing that you don't forgot is that the aliases inside the `.qrc` file must be unique for each plugins! I suggest to add the plugin name on `prefix` attribute (prefix="/bashrc"), or be careful do not mix resources of other plugins.