#summary How to make a plugin for VisualNetkit
#labels Featured,Phase-Implementation

=Making a simple plugin for a Virtual Machine element=
In this section we try to make a Plugin for a Virtual Machine. The plugin is very simple. It's just export the PS1 environment variable and some aliases.

Our plugin will have only two properties that can have two values ("true" or "false"):
 * `use PS1`
 * `use aliases`

The plugin name is *BashRC* because the plugin offer only one template builded in base of the properties values.

==The plugin.ini==
{{{
[global]
name=BashRC
type=vm
description="This plugin set PS1 env variable and/or some aliases in /root/.bashrc"
version=1.0
dependencies=""
author="Alessio Di Fazio"

[properties]
use PS1/p_default_value=true
use PS1/p_description="Set true if you want add a cool and coloured Bash promt inside the root .bashrc file, false otherwise"

use aliases/p_default_value=true
use aliases/p_description="Set true if you want add some useful aliases inside the root .bashrc file, false otherwise"
}}}

==The templates==
Inside our plugin we have three templates used to build the .bashrc final file!
===.bashrc - main===
{{{
#
# .bashrc file created by VisualNetkit BashRC plugin
#

umask 022
export TERM=xterm

# Bash completion
if [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
fi
}}}

===.bashrc - aliases part===
{{{
# Aliases
alias ls='ls --color'
alias grep='grep --color'
alias xorpsh='su xorp -p -c xorpsh'
alias ll='ls -lih --color'
alias la='ls -alh --color'
alias l='ls -ah --color'
alias ls='ls -h --color'
alias cd..='cd ..'
alias nano='nano -i -m -w -B -F -L'
}}}

===.bashrc - promt part===
{{{
# Bash promt
export PS1='\n\[\033[1;30m\][\[\033[0;33m\]\D{%d/%m/%Y %T}\[\033[1;30m\]]\n\[\033[31;04m\]\u\[\033[37;00m\]@\[\033[36;01m\]\h\[\033[37;00m\][\w]\n~> '
}}}

These two last templates is appended to the main .bashrc file if the properties are setted to "true".

==Implementing a plugin for VisualNetkit==
Sources:
 * [http://code.google.com/p/visual-netkit/source/browse/trunk/src/plugin_dev/bashrc/bashrc.pro bashrc/bashrc.pro]
 * [http://code.google.com/p/visual-netkit/source/browse/trunk/src/plugin_dev/bashrc/PluginBashRc.h bashrc/PluginBashRc.h]
 * [http://code.google.com/p/visual-netkit/source/browse/trunk/src/plugin_dev/bashrc/PluginBashRc.cpp bashrc/PluginBashRc.cpp]
 * [http://code.google.com/p/visual-netkit/source/browse/trunk/src/plugin_dev/bashrc/resources/resources.qrc bashrc/resources/resources.qrc]
 * [http://code.google.com/p/visual-netkit/source/browse/trunk/src/plugin_dev/bashrc/resources/plugin.ini bashrc/resources/plugin.ini]
 * [http://code.google.com/p/visual-netkit/source/browse/trunk/src/plugin_dev/bashrc/resources/bashrc bashrc/resources/bashrc]
 * [http://code.google.com/p/visual-netkit/source/browse/trunk/src/plugin_dev/bashrc/resources/ps1 bashrc/resources/ps1]
 * [http://code.google.com/p/visual-netkit/source/browse/trunk/src/plugin_dev/bashrc/resources/aliases bashrc/resources/aliases]

===bashrc.pro - Qt project file===
Project files contain all the information required by `qmake` to build your application, library, or plugin.

The most important variables are `TARGET`, `HEADERS` and `SOURCES`.
`TARGET` is the plugin (project) name. If you set `TARGET = foo` the plugin file will be named `libfoo.so`.

The `.pro` file for each plugin is quite standard; you have to change `HEADERS` and `SOURCES` but only adding plugin files such as PluginClass{.cpp .h} and other private classes. Do not touch the other files.

If you want more informations, please read the Qt-doc: http://doc.trolltech.com/4.4/qmake-project-files.html

===resources.qrc - Qt Resource system===
The Qt resource system is a platform-independent mechanism for storing binary files in the application's executable. This is useful if your application always needs a certain set of files (icons, translation files, etc.) and you don't want to run the risk of losing the files.

The resources associated with an application are specified in a `.qrc` file, an *XML-based* file format that lists files on the disk and optionally assigns them a resource name that the application must use to access the resource.

Our resource file:
{{{
<RCC>
    <qresource prefix="/" >
        <file alias="bash_main" >bashrc</file>
        <file alias="bash_aliases" >aliases</file>
        <file alias="bash_ps1" >ps1</file>
        <file alias="ini_bashrc" >plugin.ini</file>
    </qresource>
</RCC>
}}}

*NOTE:* The most important thing that you don't forget is that the aliases inside the `.qrc` file must be unique for each plugins! I suggest to add the plugin name on `prefix` attribute (prefix="/bashrc"), or be careful do not mix resources of other plugins using the same alias for two or more plugin`s resources.

In our example we use four templates (text files): one of these is the plugin.ini described in PluginArchitecture wiki page.

If you want more informations, please read the Qt-doc: http://doc.trolltech.com/4.4/resources.html

===PluginBashRc.h - The plugin class header===

The includes are quite standard for each plugin:
{{{
#include <QSettings>
#include "PluginInterface.h"
#include "PluginProxy.h"
#include "PluginProperty.h"
#include "VirtualMachine.h"
}}}

Our plugin must extend the PluginInterface.h (see PluginArchitecture to obtain more info) that is a pure C++ abstract class.
{{{
class PluginBashRc : public PluginInterface
}}}

The private stuff of our plugin class is showed:
{{{
private:
        QMap<QString, PluginProperty*> properties;
        QSettings *mySettings;
        PluginProxy *myProxy;
        QString myName;

        void fetchProperties();
        QString getTemplateLocation();
}}}
We use a `QMap` for store properties, a `QSetting*` to open and parse authomatically the `plugin.ini` file, the `PluginProxy*` required by interface, a `QString` that represent the plugin name readed inside the `.ini` file and two private functions.

The first is called by the constructor to fill the properties `QMap` reading these from the setting class.

The second is just for convenient; it return a `QString` that contain the template relative path (in our case: "VM_NAME/root/.bashrc".

The public part of the class is the classic header of a C++ class that contains only function of the super class to implement.

On the end we have to do factory and destroy functions as explained in PluginArchitecture page.

===PluginBashRc.cpp - The plugin class implementation===
The constructor is quite standard for each plugin.
{{{
/** 
 * Constructor 
 */
PluginBashRc::PluginBashRc() : PluginInterface()
{
        //get the ini file from resource
        mySettings = new QSettings(":/ini_bashrc", QSettings::NativeFormat);
        
        /* Save the name of this plugin for future uses */
        mySettings->beginGroup("global");
        myName = mySettings->value("name").toString();
        mySettings->endGroup();
        
        myProxy = NULL;
        fetchProperties();      //read properties from ini file
}
}}}
It init some private variables like settings, name (reading from plugin.ini), fetch the preperties and set `myProxy` to `NULL` because it's initialized and passed (`void setProxy(PluginProxy* p)`) by the system.


TODO