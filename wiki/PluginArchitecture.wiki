#summary The plugin architecture and how to make a plugin for VisualNetkit
#labels Featured,Phase-Design,Phase-Implementation

=UML class diagram=
[http://www.capponcino.it/alessio/files/universita/tesi-visual-netkit/uml/vn_plugin_framework-1.0beta.jpg]

As you can see, all wheel around the `PluginRegistry` _Singleton_ class.
This is the controller of mappings between BaseElement and the plugins attached, where BaseElement is a Virtual machine, Collision domain or a link.

The Registry offer a directory service to get and init a new plugin passing its name. In this case, the loader fartory class initialize a new instance of the selected plugins returning its Proxy.

The only possible way that plugin have to comunicate with the system is through the proxy, because it is coupled with mappings and other controllers.

=The Plugin Interface=
{{{
class PluginInterface
{

public:
        virtual ~PluginInterface() {};

        /**
         * pluginAlertMsg is a pointer to QString to show an alert if the returned
         * value is false.
         * If it is initialized, the function returns the result of consistency check.
         * If any check is failed, it returns false and an error string.
         * If the pluginAlertMsg doesn't passed (default as NULL) the property is
         * saved without any consistent check, and allways return TRUE.
         */
        virtual bool saveProperty(QString propName, QString propValue,
                        QString *pluginAlertMsg = NULL) = 0;

        /**
         * Get a QSettings* that contains the description of the plugin ini file
         */
        virtual QSettings* getMySettings() = 0;

        /**
         * Get a map of templates: the KEY is the template path relative to the laboratory
         * root; the Value represent the content of the file.
         * If the key is a known file (like host.startup) the content is appended at the
         * end of the file.
         */
        virtual QMap<QString, QString> getTemplates() = 0;

        /**
         * This function return a list of properties owned by this plugin
         */
        virtual QList<PluginProperty*> getPluginProperties() = 0;

        /**
         * Return my proxy
         */
        virtual PluginProxy* getProxy() = 0;

        /**
         * Set my proxy
         * Called by the system at initialization time
         */
        virtual void setProxy(PluginProxy* p) = 0;

        /**
         * This function is the way that the system use to know the element group.
         * A group can be for example the AS number, or Area number in routing labs.
         * Default unused and return -1.
         * NOTE: VisualNetkit-1.0b doesn't use this function at present.
         */
        virtual void setGroupID(qint32 id) { Q_UNUSED(id) };
        virtual qint32 getGroupID() { return -1; };

        /**
         * This function is called by the system (through the proxy) when the plugin
         * is created and attached to a base element. If you don't want show a label
         * on plugin startup, you have to return a empty QString()
         */
        virtual QString getDefaultGraphisLabel() = 0;

        /**
         * Get the name of this plugin, normally it's the name inside the plugin.ini
         * file
         */
        virtual QString getName() = 0;

        /**
         * This function is called by the system (through the proxy) when the plugin
         * is created and attached to a base element during laboratory open.
         * Normally inside this function you have to parse config files (full lab path is
         * passed as argument), initialize properties and finally if you want you can
         * set your own graphics label, through the proxy changeGraphicsLabel()
         * function.
         * The function return true if the parser is able to recognize datas fetching
         * own files.
         * (used in future to import netkit laboratories)
         */
        virtual bool init(QString laboratoryPath) = 0;
};

/**
 *  the types of factories
 */
typedef PluginInterface* createPlugin_t();
typedef void destroyPlugin_t(PluginInterface*);


#endif /*PLUGIN_INTERFACE_H_*/
}}}

The most impontant part is the last `typedef`. Each concrete plugin must have two `extern "C"` functions than represents the constructor and the deconstructor of the plugin.

These two function are used by the loader factory (resolving the two simbols *createPlugin* and *destroyPlugin*) to load and destroy instances of your plugin.

A tipical use of these two extern functions is showed:
{{{
/* Factory (creator) */
extern "C" PluginInterface* createPlugin()
{
    return new YourContretePluginClass();
}

/* Factory (destroyer) */
extern "C" void destroyPlugin(PluginInterface* p)
{
        delete p;
}
}}}

=A sample of plugin.ini=
{{{
[global]
name=PlugiName
type=vm|cd|link
description="a long Plugin destription
that take more then a single line!"
version=1.0
dependencies="plugin1 plugin2 plugin3"
author="author1, author2, author3"

[properties]
propName1/p_default_value=DefaultValue1
propName1/p_description="Property Description1"
propName1/p_init_order=1

propName2/p_default_value=DefaultValue2
propName2/p_description="Property Description2"
propName2/p_init_order=3

propName3/p_default_value=DefaultValue3
propName3/p_description="Property Description3"
propName3/p_init_order=2
}}}

Each property can have a `p_init_order` that represent the order integer for property position in presentation and init time.

In the our fac-simile the properties will be presented in this order:

 # propName1
 # propName3
 # propName2 

=Making a simple plugin for a VirtualMachine element=
In this section we try to make a Plugin for a Virtual Machine. The plugin is very simple. It's just export the PS1 environment variable and some aliases.

Our plugin will have only two properties that can be two values ("true" or "false"):
 * `set PS1`
 * `set aliases`

The plugin name is *BashRC* because the plugin offer only two templates; one for PS1 and one for aliases.

==The plugin.ini==
{{{
[global]
name=BashRG
type=vm
description="This plugin set PS1 env variable and/or some aliases in /root/.bashrc"
version=1.0
dependencies=""
author="Alessio Di Fazio"

[properties]
"use PS1"/p_default_value=true
"use PS1"/p_description="Set true if you want add a cool and coloured Bash promt inside the root .bashrc file, false otherwise"

"use aliases"/p_default_value=ture
"use aliases"/p_description="Set true if you want add some useful aliases inside the root .bashrc file, false otherwise"
}}}